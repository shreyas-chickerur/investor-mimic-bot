#!/usr/bin/env python3
"""
Signal Flow Tracer

Tracks every signal through the execution pipeline:
GENERATED → FILTERED → SIZED → EXECUTED → TRACKED → EXITED

Logs exact rejection reasons at each stage.
"""
import logging
from typing import Dict, List
from datetime import datetime

logger = logging.getLogger(__name__)

class SignalFlowTracer:
    """
    Traces signal flow through execution pipeline
    
    Answers: "Why did this signal not become a trade?"
    """
    
    def __init__(self, log_file: str = None, enforce_terminal_states: bool = True):
        """
        Initialize signal flow tracer
        
        Args:
            log_file: Path to detailed trace log file
            enforce_terminal_states: If True, enforce exactly one terminal state per signal
        """
        self.log_file = log_file
        self.traces = []
        self.enforce_terminal_states = enforce_terminal_states
        self.signal_terminal_states = {}  # {trace_id: terminal_state}
        
        if log_file:
            # Set up file logging
            file_handler = logging.FileHandler(log_file)
            file_handler.setLevel(logging.DEBUG)
            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)
    
    def trace_generated(self, date, strategy_name: str, signals: List[Dict]):
        """Log signals generated by strategy"""
        if not signals or len(signals) == 0:
            logger.debug(f"[GENERATED] {date} | {strategy_name} | 0 signals")
            return
        
        for sig in signals:
            trace_id = f"{date}_{sig['symbol']}_{sig['action']}"
            logger.info(f"[GENERATED] {trace_id} | {strategy_name} | {sig['action']} {sig['symbol']} @ ${sig['price']:.2f}")
            
            self.traces.append({
                'trace_id': trace_id,
                'date': date,
                'stage': 'GENERATED',
                'strategy': strategy_name,
                'signal': sig,
                'status': 'ACTIVE'
            })
    
    def trace_filtered(self, date, signal: Dict, passed: bool, reason: str = None):
        """Log signal filtering result"""
        trace_id = f"{date}_{signal['symbol']}_{signal['action']}"
        
        if passed:
            logger.info(f"[FILTERED] {trace_id} | PASSED | Correlation filter OK")
            status = 'ACTIVE'
        else:
            logger.warning(f"[FILTERED] {trace_id} | REJECTED | {reason}")
            status = 'REJECTED_FILTER'
        
        self.traces.append({
            'trace_id': trace_id,
            'date': date,
            'stage': 'FILTERED',
            'signal': signal,
            'status': status,
            'reason': reason
        })
    
    def trace_sized(self, date, signal: Dict, shares: int, reason: str = None):
        """Log position sizing result"""
        trace_id = f"{date}_{signal['symbol']}_{signal['action']}"
        
        if shares > 0:
            logger.info(f"[SIZED] {trace_id} | {shares} shares | Value: ${shares * signal['price']:.2f}")
            status = 'ACTIVE'
        else:
            logger.error(f"[SIZED] {trace_id} | ZERO SHARES | {reason}")
            status = 'REJECTED_SIZING'
        
        self.traces.append({
            'trace_id': trace_id,
            'date': date,
            'stage': 'SIZED',
            'signal': signal,
            'shares': shares,
            'status': status,
            'reason': reason
        })
    
    def trace_risk_check(self, date, signal: Dict, passed: bool, reason: str = None):
        """Log portfolio risk check result"""
        trace_id = f"{date}_{signal['symbol']}_{signal['action']}"
        
        if passed:
            logger.info(f"[RISK_CHECK] {trace_id} | PASSED | Portfolio risk OK")
            status = 'ACTIVE'
        else:
            logger.warning(f"[RISK_CHECK] {trace_id} | REJECTED | {reason}")
            status = 'REJECTED_RISK'
        
        self.traces.append({
            'trace_id': trace_id,
            'date': date,
            'stage': 'RISK_CHECK',
            'signal': signal,
            'status': status,
            'reason': reason
        })
    
    def trace_executed(self, date, signal: Dict, execution_price: float, total_cost: float):
        """Log successful trade execution"""
        trace_id = f"{date}_{signal['symbol']}_{signal['action']}"
        
        logger.info(f"[EXECUTED] {trace_id} | Price: ${execution_price:.2f} | Cost: ${total_cost:.2f}")
        
        self.traces.append({
            'trace_id': trace_id,
            'date': date,
            'stage': 'EXECUTED',
            'signal': signal,
            'execution_price': execution_price,
            'total_cost': total_cost,
            'status': 'EXECUTED'
        })
    
    def trace_tracked(self, date, symbol: str, position: Dict):
        """Log position tracking"""
        trace_id = f"{date}_{symbol}_HOLD"
        
        logger.debug(f"[TRACKED] {trace_id} | Shares: {position['shares']} | Entry: ${position['entry_price']:.2f}")
        
        self.traces.append({
            'trace_id': trace_id,
            'date': date,
            'stage': 'TRACKED',
            'symbol': symbol,
            'position': position,
            'status': 'HOLDING'
        })
    
    def trace_exited(self, date, symbol: str, exit_price: float, pnl: float, reason: str):
        """Log position exit"""
        trace_id = f"{date}_{symbol}_EXIT"
        
        logger.info(f"[EXITED] {trace_id} | Price: ${exit_price:.2f} | P&L: ${pnl:.2f} | {reason}")
        
        self.traces.append({
            'trace_id': trace_id,
            'date': date,
            'stage': 'EXITED',
            'symbol': symbol,
            'exit_price': exit_price,
            'pnl': pnl,
            'reason': reason,
            'status': 'CLOSED'
        })
    
    def get_rejection_summary(self) -> Dict:
        """Get summary of all rejections"""
        rejections = [t for t in self.traces if 'REJECTED' in t.get('status', '')]
        
        summary = {
            'total_rejections': len(rejections),
            'by_stage': {},
            'by_reason': {}
        }
        
        for rej in rejections:
            stage = rej['stage']
            reason = rej.get('reason', 'Unknown')
            
            summary['by_stage'][stage] = summary['by_stage'].get(stage, 0) + 1
            summary['by_reason'][reason] = summary['by_reason'].get(reason, 0) + 1
        
        return summary
    
    def get_execution_summary(self) -> Dict:
        """Get summary of executions"""
        executed = [t for t in self.traces if t.get('status') == 'EXECUTED']
        exited = [t for t in self.traces if t.get('status') == 'CLOSED']
        
        return {
            'total_executed': len(executed),
            'total_exited': len(exited),
            'currently_holding': len(executed) - len(exited)
        }
    
    def print_summary(self):
        """Print summary of signal flow"""
        logger.info("\n" + "="*80)
        logger.info("SIGNAL FLOW SUMMARY")
        logger.info("="*80)
        
        rejection_summary = self.get_rejection_summary()
        execution_summary = self.get_execution_summary()
        
        logger.info(f"\nExecutions:")
        logger.info(f"  Total Executed: {execution_summary['total_executed']}")
        logger.info(f"  Total Exited: {execution_summary['total_exited']}")
        logger.info(f"  Currently Holding: {execution_summary['currently_holding']}")
        
        logger.info(f"\nRejections:")
        logger.info(f"  Total Rejected: {rejection_summary['total_rejections']}")
        
        if rejection_summary['by_stage']:
            logger.info(f"\n  By Stage:")
            for stage, count in rejection_summary['by_stage'].items():
                logger.info(f"    {stage}: {count}")
        
        if rejection_summary['by_reason']:
            logger.info(f"\n  By Reason:")
            for reason, count in rejection_summary['by_reason'].items():
                logger.info(f"    {reason}: {count}")

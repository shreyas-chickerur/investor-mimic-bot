diff --git a/src/multi_strategy_main.py b/src/multi_strategy_main.py
index original..fixed 100644
--- a/src/multi_strategy_main.py
+++ b/src/multi_strategy_main.py
@@ -17,7 +17,7 @@ sys.path.insert(0, str(project_root / 'src'))
 from dotenv import load_dotenv
 load_dotenv()
 
-from strategy_database import StrategyDatabase
+from phase5_database import Phase5Database
 from strategies.strategy_rsi_mean_reversion import RSIMeanReversionStrategy
 from strategies.strategy_ml_momentum import MLMomentumStrategy
 from strategies.strategy_news_sentiment import NewsSentimentStrategy
@@ -56,8 +56,9 @@ class MultiStrategyRunner:
     """Runs all 5 strategies with independent tracking"""
     
     def __init__(self):
-        self.db = StrategyDatabase()
+        self.db = Phase5Database('trading.db')
+        self.run_id = self.db.run_id
         self.asof_date = datetime.now().strftime('%Y-%m-%d')
+        logger.info(f"Phase 5 Run ID: {self.run_id}")
         
         # Get Alpaca credentials
@@ -67,11 +68,20 @@ class MultiStrategyRunner:
         if not api_key or not secret_key:
             raise ValueError("Missing Alpaca credentials")
         
-        paper_mode = os.getenv('ALPACA_PAPER', 'true').lower() == 'true'
+        self.paper_mode = os.getenv('ALPACA_PAPER', 'true').lower() == 'true'
         live_enabled = os.getenv('ALPACA_LIVE_ENABLED', 'false').lower() == 'true'
-        if not paper_mode and not live_enabled:
+        if not self.paper_mode and not live_enabled:
             raise ValueError("Live trading disabled. Set ALPACA_LIVE_ENABLED=true to trade live.")
-        self.trading_client = TradingClient(api_key, secret_key, paper=paper_mode)
+        self.trading_client = TradingClient(api_key, secret_key, paper=self.paper_mode)
+        
+        # PHASE 5 VALIDATION: Signal injection
+        self.signal_injection_enabled = os.getenv('PHASE5_SIGNAL_INJECTION', 'false').lower() == 'true'
+        if self.signal_injection_enabled:
+            if not self.paper_mode:
+                raise ValueError("Signal injection requires ALPACA_PAPER=true")
+            logger.warning("=" * 80)
+            logger.warning("PHASE5_SIGNAL_INJECTION ENABLED - VALIDATION ONLY")
+            logger.warning("=" * 80)
         
         # Get account info - CRITICAL FIX: Use portfolio value, not just cash
         account = self.trading_client.get_account()
@@ -120,6 +130,40 @@ class MultiStrategyRunner:
         self.cash_available = float(account.cash)
         return account
 
+    def _refresh_account_state(self):
+        """Alias for compatibility"""
+        return self._refresh_account_values()
+    
+    def _get_last_close_map(self, market_data) -> dict:
+        """Extract last close price per symbol from market_data DataFrame"""
+        import pandas as pd
+        try:
+            if 'symbol' in market_data.columns and 'close' in market_data.columns:
+                last = market_data.sort_index().groupby('symbol')['close'].last()
+                return last.dropna().astype(float).to_dict()
+            if isinstance(market_data.index, pd.MultiIndex) and 'close' in market_data.columns:
+                sym_level = 'symbol' if 'symbol' in market_data.index.names else market_data.index.names[-1]
+                last = market_data.reset_index().sort_values(market_data.index.names[0]).groupby(sym_level)['close'].last()
+                return last.dropna().astype(float).to_dict()
+            if isinstance(market_data.columns, pd.MultiIndex):
+                if 'close' in market_data.columns.get_level_values(0):
+                    close_df = market_data['close']
+                    last = close_df.iloc[-1]
+                    return last.dropna().astype(float).to_dict()
+                elif 'close' in market_data.columns.get_level_values(1):
+                    close_df = market_data.xs('close', axis=1, level=1)
+                    last = close_df.iloc[-1]
+                    return last.dropna().astype(float).to_dict()
+            return {}
+        except Exception as e:
+            logger.warning(f"Could not extract close prices: {e}")
+            return {}
+
     def update_pnl_metrics(self):
         """Calculate and update daily/cumulative P&L and drawdown."""
         account = self._refresh_account_values()
@@ -285,6 +329,18 @@ class MultiStrategyRunner:
         if not self.portfolio_risk.check_daily_loss_limit(self.portfolio_value):
             logger.warning("Trading halted due to daily loss limit")
             return []
+        
+        # Save START snapshot
+        logger.info("Saving START broker snapshot...")
+        account = self.trading_client.get_account()
+        broker_positions = self.trading_client.get_all_positions()
+        self.db.save_broker_state(
+            snapshot_date=self.asof_date,
+            snapshot_type='START',
+            cash=float(account.cash),
+            portfolio_value=float(account.portfolio_value),
+            buying_power=float(account.buying_power),
+            positions=[{'symbol': p.symbol, 'qty': float(p.qty), 'market_value': float(p.market_value)} for p in broker_positions],
+            reconciliation_status='SKIPPED',
+            discrepancies=[]
+        )
 
         if os.getenv('ENABLE_BROKER_RECONCILIATION', 'false').lower() == 'true':
@@ -298,6 +354,19 @@ class MultiStrategyRunner:
             )
             self.reconciliation_status = "PASS" if success else "FAIL"
             self.reconciliation_discrepancies = discrepancies
+            
+            # Save RECONCILIATION snapshot
+            logger.info(f"Saving RECONCILIATION snapshot (status: {self.reconciliation_status})...")
+            account = self.trading_client.get_account()
+            broker_positions = self.trading_client.get_all_positions()
+            self.db.save_broker_state(
+                snapshot_date=self.asof_date,
+                snapshot_type='RECONCILIATION',
+                cash=float(account.cash),
+                portfolio_value=float(account.portfolio_value),
+                buying_power=float(account.buying_power),
+                positions=[{'symbol': p.symbol, 'qty': float(p.qty), 'market_value': float(p.market_value)} for p in broker_positions],
+                reconciliation_status=self.reconciliation_status,
+                discrepancies=discrepancies
+            )
+            
             if not success:
                 logger.error("Broker reconciliation failed; trading paused")
                 self.errors.extend(discrepancies)
@@ -308,6 +377,32 @@ class MultiStrategyRunner:
         print("=" * 80)
         
         all_signals = []
+        
+        # PHASE 5 VALIDATION: Inject synthetic signals if enabled
+        injected_signals = []
+        if self.signal_injection_enabled:
+            logger.info("=" * 80)
+            logger.info("PHASE 5 SIGNAL INJECTION - Generating validation signals")
+            logger.info("=" * 80)
+            
+            current_prices = self._get_last_close_map(market_data)
+            logger.info(f"Extracted prices for {len(current_prices)} symbols")
+            
+            available_symbols = list(current_prices.keys())[:2]
+            
+            for symbol in available_symbols:
+                if symbol in current_prices:
+                    injected_signal = {
+                        'symbol': symbol,
+                        'action': 'BUY',
+                        'confidence': 0.75,
+                        'reasoning': 'PHASE5_VALIDATION: Synthetic signal for non-zero path proof',
+                        'price': current_prices[symbol],
+                        'injected': True,
+                        'injection_source': 'PHASE5_VALIDATION'
+                    }
+                    injected_signals.append(injected_signal)
+                    logger.info(f"  [INJECTION] BUY {symbol} @ ${current_prices[symbol]:.2f}")
+            
+            logger.info(f"Generated {len(injected_signals)} validation signals")
+            logger.info("These signals will go through normal correlation filter, risk checks, and sizing")
+            logger.info("=" * 80)
         
         for strategy in strategies:
             print(f"\nüìà {strategy.name}")
@@ -319,6 +414,13 @@ class MultiStrategyRunner:
 
                 signals = strategy.generate_signals(market_data)
+                
+                # PHASE 5 VALIDATION: Route injected signals to RSI Mean Reversion
+                if self.signal_injection_enabled and strategy.name == "RSI Mean Reversion" and len(injected_signals) > 0:
+                    logger.info(f"  [INJECTION] Routing {len(injected_signals)} validation signals to {strategy.name}")
+                    signals = injected_signals + (signals if signals else [])
+                    injected_signals = []
+                
                 self.raw_signals_by_strategy[strategy.name] = list(signals) if signals else []
                 
                 if signals and len(signals) > 0:
@@ -330,11 +432,16 @@ class MultiStrategyRunner:
                     )
 
                     # Log signals to database
+                    signal_ids = []
                     for signal in signals:
-                        self.db.log_signal(
+                        signal_id = self.db.log_signal(
                             strategy.strategy_id,
                             signal.get('symbol'),
                             signal.get('action', 'BUY'),
                             signal.get('confidence', 0.5),
-                            signal.get('reasoning', '')
+                            signal.get('reasoning', ''),
+                            self.asof_date
                         )
+                        signal_ids.append(signal_id)
+                        signal['signal_id'] = signal_id
                     
                     # Execute trades
@@ -345,6 +452,22 @@ class MultiStrategyRunner:
                     )  # Top 3 signals
                     self.executed_signals.extend(executed)
                     all_signals.extend(executed)
+                    
+                    # Set terminal states for all signals
+                    for i, signal in enumerate(signals[:3]):
+                        signal_id = signal.get('signal_id')
+                        if signal_id:
+                            was_executed = any(e.get('symbol') == signal.get('symbol') for e in executed)
+                            if was_executed:
+                                self.db.update_signal_terminal_state(signal_id, 'EXECUTED', 'trade_submitted')
+                            else:
+                                self.db.update_signal_terminal_state(signal_id, 'FILTERED', 'risk_or_cash_limit')
+                    
+                    # Mark remaining signals as FILTERED
+                    for signal in signals[3:]:
+                        signal_id = signal.get('signal_id')
+                        if signal_id:
+                            self.db.update_signal_terminal_state(signal_id, 'FILTERED', 'top_3_throttle')
                 else:
                     print("‚ùå No signals generated")
                 
@@ -356,6 +479,19 @@ class MultiStrategyRunner:
                 print(f"‚ùå Error: {e}")
                 self.errors.append(f"{strategy.name}: {e}")
         
+        # Save END snapshot (always, even if errors)
+        logger.info("Saving END broker snapshot...")
+        account = self.trading_client.get_account()
+        broker_positions = self.trading_client.get_all_positions()
+        self.db.save_broker_state(
+            snapshot_date=self.asof_date,
+            snapshot_type='END',
+            cash=float(account.cash),
+            portfolio_value=float(account.portfolio_value),
+            buying_power=float(account.buying_power),
+            positions=[{'symbol': p.symbol, 'qty': float(p.qty), 'market_value': float(p.market_value)} for p in broker_positions],
+            reconciliation_status=self.reconciliation_status,
+            discrepancies=self.reconciliation_discrepancies
+        )
+        
         return all_signals
     
     def _execute_strategy_trades(self, strategy, signals, total_exposure, portfolio_value):
